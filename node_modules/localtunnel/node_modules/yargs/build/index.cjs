'use strict';

var assert = require('assert');

class YError extends Error {
    constructor(msg) {
        super(msg || 'yargs error');
        this.name = 'YError';
        Error.captureStackTrace(this, YError);
    }
}

let previouslyVisitedConfigs = [];
let shim;
function applyExtends(config, cwd, mergeExtends, _shim) {
    shim = _shim;
    let defaultConfig = {};
    if (Object.prototype.hasOwnProperty.call(config, 'extends')) {
        if (typeof config.extends !== 'string')
            return defaultConfig;
        const isPath = /\.json|\..*rc$/.test(config.extends);
        let pathToDefault = null;
        if (!isPath) {
            try {
                pathToDefault = require.resolve(config.extends);
            }
            catch (_err) {
                return config;
            }
        }
        else {
            pathToDefault = getPathToDefaultConfig(cwd, config.extends);
        }
        checkForCircularExtends(pathToDefault);
        previouslyVisitedConfigs.push(pathToDefault);
        defaultConfig = isPath
            ? JSON.parse(shim.readFileSync(pathToDefault, 'utf8'))
            : require(config.extends);
        delete config.extends;
        defaultConfig = applyExtends(defaultConfig, shim.path.dirname(pathToDefault), mergeExtends, shim);
    }
    previouslyVisitedConfigs = [];
    return mergeExtends
        ? mergeDeep(defaultConfig, config)
        : Object.assign({}, defaultConfig, config);
}
function checkForCircularExtends(cfgPath) {
    if (previouslyVisitedConfigs.indexOf(cfgPath) > -1) {
        throw new YError(`Circular extended configurations: '${cfgPath}'.`);
    }
}
function getPathToDefaultConfig(cwd, pathToExtend) {
    return shim.path.resolve(cwd, pathToExtend);
}
function mergeDeep(config1, config2) {
    const target = {};
    function isObject(obj) {
        return obj && typeof obj === 'object' && !Array.isArray(obj);
    }
    Object.assign(target, config1);
    for (const key of Object.keys(config2)) {
        if (isObject(config2[key]) && isObject(target[key])) {
            target[key] = mergeDeep(config1[key], config2[key]);
        }
        else {
            target[key] = config2[key];
        }
    }
    return target;
}

function parseCommand(cmd) {
    const extraSpacesStrippedCommand = cmd.replace(/\s{2,}/g, ' ');
    const splitCommand = extraSpacesStrippedCommand.split(/\s+(?![^[]*]|[^<]*>)/);
    const bregex = /\.*[\][<>]/g;
    const firstCommand = splitCommand.shift();
    if (!firstCommand)
        throw new Error(`No command found in: ${cmd}`);
    const parsedCommand = {
        cmd: firstCommand.replace(bregex, ''),
        demanded: [],
        optional: [],
    };
    splitCommand.forEach((cmd, i) => {
        let variadic = false;
        cmd = cmd.replace(/\s/g, '');
        if (/\.+[\]>]/.test(cmd) && i === splitCommand.length - 1)
            variadic = true;
        if (/^\[/.test(cmd)) {
            parsedCommand.optional.push({
                cmd: cmd.replace(bregex, '').split('|'),
                variadic,
            });
        }
        else {
            parsedCommand.demanded.push({
                cmd: cmd.replace(bregex, '').split('|'),
                variadic,
            });
        }
    });
    return parsedCommand;
}

const positionName = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth'];
function argsert(arg1, arg2, arg3) {
    function parseArgs() {
        return typeof arg1 === 'object'
            ? [{ demanded: [], optional: [] }, arg1, arg2]
            : [
                parseCommand(`cmd ${arg1}`),
                arg2,
                arg3,
            ];
    }
    try {
        let position = 0;
        const [parsed, callerArguments, _length] = parseArgs();
        const args = [].slice.call(callerArguments);
        while (args.length && args[args.length - 1] === undefined)
            args.pop();
        const length = _length || args.length;
        if (length < parsed.demanded.length) {
            throw new YError(`Not enough arguments provided. Expected ${parsed.demanded.length} but received ${args.length}.`);
        }
        const totalCommands = parsed.demanded.length + parsed.optional.length;
        if (length > totalCommands) {
            throw new YError(`Too many arguments provided. Expected max ${totalCommands} but received ${length}.`);
        }
        parsed.demanded.forEach(demanded => {
            const arg = args.shift();
            const observedType = guessType(arg);
            const matchingTypes = demanded.cmd.filter(type => type === observedType || type === '*');
            if (matchingTypes.length === 0)
                argumentTypeError(observedType, demanded.cmd, position);
            position += 1;
        });
        parsed.optional.forEach(optional => {
            if (args.length === 0)
                return;
            const arg = args.shift();
            const observedType = guessType(arg);
            const matchingTypes = optional.cmd.filter(type => type === observedType || type === '*');
            if (matchingTypes.length === 0)
                argumentTypeError(observedType, optional.cmd, position);
            position += 1;
        });
    }
    catch (err) {
        console.warn(err.stack);
    }
}
function guessType(arg) {
    if (Array.isArray(arg)) {
        return 'array';
    }
    else if (arg === null) {
        return 'null';
    }
    return typeof arg;
}
function argumentTypeError(observedType, allowedTypes, position) {
    throw new YError(`Invalid ${positionName[position] || 'manyith'} argument. Expected ${allowedTypes.join(' or ')} but received ${observedType}.`);
}

function isPromise(maybePromise) {
    return (!!maybePromise &&
        !!maybePromise.then &&
        typeof maybePromise.then === 'function');
}

function assertNotStrictEqual(actual, expected, shim, message) {
    shim.assert.notStrictEqual(actual, expected, message);
}
function assertSingleKey(actual, shim) {
    shim.assert.strictEqual(typeof actual, 'string');
}
function objectKeys(object) {
    return Object.keys(object);
}

function objFilter(original = {}, filter = () => true) {
    const obj = {};
    objectKeys(original).forEach(key => {
        if (filter(key, original[key])) {
            obj[key] = original[key];
        }
    });
    return obj;
}

function globalMiddlewareFactory(globalMiddleware, context) {
    return function (callback, applyBeforeValidation = false) {
        argsert('<array|function> [boolean]', [callback, applyBeforeValidation], arguments.length);
        if (Array.isArray(callback)) {
            for (let i = 0; i < callback.length; i++) {
                if (typeof callback[i] !== 'function') {
                    throw Error('middleware must be a function');
                }
                callback[i].applyBeforeValidation = applyBeforeValidation;
            }
            Array.prototype.push.apply(globalMiddleware, callback);
        }
        else if (typeof callback === 'function') {
            callback.applyBeforeValidation = applyBeforeValidation;
            globalMiddleware.push(callback);
        }
        return context;
    };
}
function commandMiddlewareFactory(commandMiddleware) {
    if (!commandMiddleware)
        return [];
    return commandMiddleware.map(middleware => {
        middleware.applyBeforeValidation = false;
        return middleware;
    });
}
function applyMiddleware(argv, yargs, middlewares, beforeValidation) {
    const beforeValidationError = new Error('middleware cannot return a promise when applyBeforeValidation is true');
    return middlewares.reduce((acc, middleware) => {
        if (middleware.applyBeforeValidation !== beforeValidation) {
            return acc;
        }
        if (isPromise(acc)) {
            return acc
                .then(initialObj => Promise.all([
                initialObj,
                middleware(initialObj, yargs),
            ]))
                .then(([initialObj, middlewareObj]) => Object.assign(initialObj, middlewareObj));
        }
        else {
            const result = middleware(acc, yargs);
            if (beforeValidation && isPromise(result))
                throw beforeValidationError;
            return isPromise(result)
                ? result.then(middlewareObj => Object.assign(acc, middlewareObj))
                : Object.assign(acc, result);
        }
    }, argv);
}

function getProcessArgvBinIndex() {
    if (isBundledElectronApp())
        return 0;
    return 1;
}
function isBundledElectronApp() {
    return isElectronApp() && !process.defaultApp;
}
function isElectronApp() {
    return !!process.versions.electron;
}
function hideBin(argv) {
    return argv.slice(getProcessArgvBinIndex() + 1);
}
function getProcessArgvBin() {
    return process.argv[getProcessArgvBinIndex()];
}

var processArgv = /*#__PURE__*/Object.freeze({
  __proto__: null,
  hideBin: hideBin,
  getProcessArgvBin: getProcessArgvBin
});

function whichModule(exported) {
    if (typeof require === 'undefined')
        return null;
    for (let i = 0, files = Object.keys(require.cache), mod; i < files.length; i++) {
        mod = require.cache[files[i]];
        if (mod.exports === exported)
            return mod;
    }
    return null;
}

const DEFAULT_MARKER = /(^\*)|(^\$0)/;
function command(yargs, usage, validation, globalMiddleware = [], shim) {
    const self = {};
    let handlers = {};
    let aliasMap = {};
    let defaultCommand;
    self.addHandler = function addHandler(cmd, description, builder, handler, commandMiddleware, deprecated) {
        let aliases = [];
        const middlewares = commandMiddlewareFactory(commandMiddleware);
        handler = handler || (() => { });
        if (Array.isArray(cmd)) {
            if (isCommandAndAliases(cmd)) {
                [cmd, ...aliases] = cmd;
            }
            else {
                for (const command of cmd) {
                    self.addHandler(command);
                }
            }
        }
        else if (isCommandHandlerDefinition(cmd)) {
            let command = Array.isArray(cmd.command) || typeof cmd.command === 'string'
                ? cmd.command
                : moduleName(cmd);
            if (cmd.aliases)
                command = [].concat(command).concat(cmd.aliases);
            self.addHandler(command, extractDesc(cmd), cmd.builder, cmd.handler, cmd.middlewares, cmd.deprecated);
            return;
        }
        else if (isCommandBuilderDefinition(builder)) {
            self.addHandler([cmd].concat(aliases), description, builder.builder, builder.handler, builder.middlewares, builder.deprecated);
            return;
        }
        if (typeof cmd === 'string') {
            const parsedCommand = parseCommand(cmd);
            aliases = aliases.map(alias => parseCommand(alias).cmd);
            let isDefault = false;
            const parsedAliases = [parsedCommand.cmd].concat(aliases).filter(c => {
                if (DEFAULT_MARKER.test(c)) {
                    isDefault = true;
                    return false;
                }
                return true;
            });
            if (parsedAliases.length === 0 && isDefault)
                parsedAliases.push('$0');
            if (isDefault) {
                parsedCommand.cmd = parsedAliases[0];
                aliases = parsedAliases.slice(1);
                cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd);
            }
            aliases.forEach(alias => {
                aliasMap[alias] = parsedCommand.cmd;
            });
            if (description !== false) {
                usage.command(cmd, description, isDefault, aliases, deprecated);
            }
            handlers[parsedCommand.cmd] = {
                original: cmd,
                description,
                handler,
                builder: builder || {},
                middlewares,
                deprecated,
                demanded: parsedCommand.demanded,
                optional: parsedCommand.optional,
            };
            if (isDefault)
                defaultCommand = handlers[parsedCommand.cmd];
        }
    };
    self.addDirectory = function addDirectory(dir, context, req, callerFile, opts) {
        opts = opts || {};
        if (typeof opts.recurse !== 'boolean')
            opts.recurse = false;
        if (!Array.isArray(opts.extensions))
            opts.extensions = ['js'];
        const parentVisit = typeof opts.visit === 'function' ? opts.visit : (o) => o;
        opts.visit = function visit(obj, joined, filename) {
            const visited = parentVisit(obj, joined, filename);
            if (visited) {
                if (~context.files.indexOf(joined))
                    return visited;
                context.files.push(joined);
                self.addHandler(visited);
            }
            return visited;
        };
        shim.requireDirectory({ require: req, filename: callerFile }, dir, opts);
    };
    function moduleName(obj) {
        const mod = whichModule(obj);
        if (!mod)
            throw new Error(`No command name given for module: ${shim.inspect(obj)}`);
        return commandFromFilename(mod.filename);
    }
    function commandFromFilename(filename) {
        return shim.path.basename(filename, shim.path.extname(filename));
    }
    function extractDesc({ describe, description, desc, }) {
        for (const test of [describe, description, desc]) {
            if (typeof test === 'string' || test === false)
                return test;
            assertNotStrictEqual(test, true, shim);
        }
        return false;
    }
    self.getCommands = () => Object.keys(handlers).concat(Object.keys(aliasMap));
    self.getCommandHandlers = () => handlers;
    self.hasDefaultCommand = () => !!defaultCommand;
    self.runCommand = function runCommand(command, yargs, parsed, commandIndex) {
        let aliases = parsed.aliases;
        const commandHandler = handlers[command] || handlers[aliasMap[command]] || defaultCommand;
        const currentContext = yargs.getContext();
        let numFiles = currentContext.files.length;
        const parentCommands = currentContext.commands.slice();
        let innerArgv = parsed.argv;
        let positionalMap = {};
        if (command) {
            currentContext.commands.push(command);
            currentContext.fullCommands.push(commandHandler.original);
        }
        const builder = commandHandler.builder;
        if (isCommandBuilderCallback(builder)) {
            const builderOutput = builder(yargs.reset(parsed.aliases));
            const innerYargs = isYargsInstance(builderOutput) ? builderOutput : yargs;
            if (shouldUpdateUsage(innerYargs)) {
                innerYargs
                    .getUsageInstance()
                    .usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);
            }
            innerArgv = innerYargs._parseArgs(null, null, true, commandIndex);
            aliases = innerYargs.parsed.aliases;
        }
        else if (isCommandBuilderOptionDefinitions(builder)) {
            const innerYargs = yargs.reset(parsed.aliases);
            if (shouldUpdateUsage(innerYargs)) {
                innerYargs
                    .getUsageInstance()
                    .usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);
            }
            Object.keys(commandHandler.builder).forEach(key => {
                innerYargs.option(key, builder[key]);
            });
            innerArgv = innerYargs._parseArgs(null, null, true, commandIndex);
            aliases = innerYargs.parsed.aliases;
        }
        if (!yargs._hasOutput()) {
            positionalMap = populatePositionals(commandHandler, innerArgv, currentContext);
        }
        const middlewares = globalMiddleware
            .slice(0)
            .concat(commandHandler.middlewares);
        applyMiddleware(innerArgv, yargs, middlewares, true);
        if (!yargs._hasOutput()) {
            yargs._runValidation(innerArgv, aliases, positionalMap, yargs.parsed.error, !command);
        }
        if (commandHandler.handler && !yargs._hasOutput()) {
            yargs._setHasOutput();
            const populateDoubleDash = !!yargs.getOptions().configuration['populate--'];
            yargs._postProcess(innerArgv, populateDoubleDash);
            innerArgv = applyMiddleware(innerArgv, yargs, middlewares, false);
            let handlerResult;
            if (isPromise(innerArgv)) {
                handlerResult = innerArgv.then(argv => commandHandler.handler(argv));
            }
            else {
                handlerResult = commandHandler.handler(innerArgv);
            }
            const handlerFinishCommand = yargs.getHandlerFinishCommand();
            if (isPromise(handlerResult)) {
                yargs.getUsageInstance().cacheHelpMessage();
                handlerResult
                    .then(value => {
                    if (handlerFinishCommand) {
                        handlerFinishCommand(value);
                    }
                })
                    .catch(error => {
                    try {
                        yargs.getUsageInstance().fail(null, error);
                    }
                    catch (err) {
                    }
                })
                    .then(() => {
                    yargs.getUsageInstance().clearCachedHelpMessage();
                });
            }
            else {
                if (handlerFinishCommand) {
                    handlerFinishCommand(handlerResult);
                }
            }
        }
        if (command) {
            currentContext.commands.pop();
            currentContext.fullCommands.pop();
        }
        numFiles = currentContext.files.length - numFiles;
        if (numFiles > 0)
            currentContext.files.splice(numFiles * -1, numFiles);
        return innerArgv;
    };
    function shouldUpdateUsage(yargs) {
        return (!yargs.getUsageInstance().getUsageDisabled() &&
            yargs.getUsageInstance().getUsage().length === 0);
    }
    function usageFromParentCommandsCommandHandler(parentCommands, commandHandler) {
        const c = DEFAULT_MARKER.test(commandHandler.original)
            ? commandHandler.original.replace(DEFAULT_MARKER, '').trim()
            : commandHandler.original;
        const pc = parentCommands.filter(c => {
            return !DEFAULT_MARKER.test(c);
        });
        pc.push(c);
        return `$0 ${pc.join(' ')}`;
    }
    self.runDefaultBuilderOn = function (yargs) {
        assertNotStrictEqual(defaultCommand, undefined, shim);
        if (shouldUpdateUsage(yargs)) {
            const commandString = DEFAULT_MARKER.test(defaultCommand.original)
                ? defaultCommand.original
                : defaultCommand.original.replace(/^[^[\]<>]*/, '$0 ');
            yargs.getUsageInstance().usage(commandString, defaultCommand.description);
        }
        const builder = defaultCommand.builder;
        if (isCommandBuilderCallback(builder)) {
            builder(yargs);
        }
        else if (!isCommandBuilderDefinition(builder)) {
            Object.keys(builder).forEach(key => {
                yargs.option(key, builder[key]);
            });
        }
    };
    function populatePositionals(commandHandler, argv, context) {
        argv._ = argv._.slice(context.commands.length);
        const demanded = commandHandler.demanded.slice(0);
        const optional = commandHandler.optional.slice(0);
        const positionalMap = {};
        validation.positionalCount(demanded.length, argv._.length);
        while (demanded.length) {
            const demand = demanded.shift();
            populatePositional(demand, argv, positionalMap);
        }
        while (optional.length) {
            const maybe = optional.shift();
            populatePositional(maybe, argv, positionalMap);
        }
        argv._ = context.commands.concat(argv._.map(a => '' + a));
        postProcessPositionals(argv, positionalMap, self.cmdToParseOptions(commandHandler.original));
        return positionalMap;
    }
    function populatePositional(positional, argv, positionalMap) {
        const cmd = positional.cmd[0];
        if (positional.variadic) {
            positionalMap[cmd] = argv._.splice(0).map(String);
        }
        else {
            if (argv._.length)
                positionalMap[cmd] = [String(argv._.shift())];
        }
    }
    function postProcessPositionals(argv, positionalMap, parseOptions) {
        const options = Object.assign({}, yargs.getOptions());
        options.default = Object.assign(parseOptions.default, options.default);
        for (const key of Object.keys(parseOptions.alias)) {
            options.alias[key] = (options.alias[key] || []).concat(parseOptions.alias[key]);
        }
        options.array = options.array.concat(parseOptions.array);
        options.config = {};
        const unparsed = [];
        Object.keys(positionalMap).forEach(key => {
            positionalMap[key].map(value => {
                if (options.configuration['unknown-options-as-args'])
                    options.key[key] = true;
                unparsed.push(`--${key}`);
                unparsed.push(value);
            });
        });
        if (!unparsed.length)
            return;
        const config = Object.assign({}, options.configuration, {
            'populate--': true,
        });
        const parsed = shim.Parser.detailed(unparsed, Object.assign({}, options, {
            configuration: config,
        }));
        if (parsed.error) {
            yargs.getUsageInstance().fail(parsed.error.message, parsed.error);
        }
        else {
            const positionalKeys = Object.keys(positionalMap);
            Object.keys(positionalMap).forEach(key => {
                positionalKeys.push(...parsed.aliases[key]);
            });
            Object.keys(parsed.argv).forEach(key => {
                if (positionalKeys.indexOf(key) !== -1) {
                    if (!positionalMap[key])
                        positionalMap[key] = parsed.argv[key];
                    argv[key] = parsed.argv[key];
                }
            });
        }
    }
    self.cmdToParseOptions = function (cmdString) {
        const parseOptions = {
            array: [],
            default: {},
            alias: {},
            demand: {},
        };
        const parsed = parseCommand(cmdString);
        parsed.demanded.forEach(d => {
            const [cmd, ...aliases] = d.cmd;
            if (d.variadic) {
                parseOptions.array.push(cmd);
                parseOptions.default[cmd] = [];
            }
            parseOptions.alias[cmd] = aliases;
            parseOptions.demand[cmd] = true;
        });
        parsed.optional.forEach(o => {
            const [cmd, ...aliases] = o.cmd;
            if (o.variadic) {
                parseOptions.array.push(cmd);
                parseOptions.default[cmd] = [];
            }
            parseOptions.alias[cmd] = aliases;
        });
        return parseOptions;
    };
    self.reset = () => {
        handlers = {};
        aliasMap = {};
        defaultCommand = undefined;
        return self;
    };
    const frozens = [];
    self.freeze = () => {
        frozens.push({
            handlers,
            aliasMap,
            defaultCommand,
        });
    };
    self.unfreeze = () => {
        const frozen = frozens.pop();
        assertNotStrictEqual(frozen, undefined, shim);
        ({ handlers, aliasMap, defaultCommand } = frozen);
    };
    return self;
}
function isCommandBuilderDefinition(builder) {
    return (typeof builder === 'object' &&
        !!builder.builder &&
        typeof builder.handler === 'function');
}
function isCommandAndAliases(cmd) {
    if (cmd.every(c => typeof c === 'string')) {
        return true;
    }
    else {
        return false;
    }
}
function isCommandBuilderCallback(builder) {
    return typeof builder === 'function';
}
function isCommandBuilderOptionDefinitions(builder) {
    return typeof builder === 'object';
}
function isCommandHandlerDefinition(cmd) {
    return typeof cmd === 'object' && !Array.isArray(cmd);
}

function setBlocking(blocking) {
    if (typeof process === 'undefined')
        return;
    [process.stdout, process.stderr].forEach(_stream => {
        const stream = _stream;
        if (stream._handle &&
            stream.isTTY &&
            typeof stream._handle.setBlocking === 'function') {
            stream._handle.setBlocking(blocking);
        }
    });
}

function usage(yargs, y18n, shim) {
    const __ = y18n.__;
    const self = {};
    const fails = [];
    self.failFn = function failFn(f) {
        fails.push(f);
    };
    let failMessage = null;
    let showHelpOnFail = true;
    self.showHelpOnFail = function showHelpOnFailFn(arg1 = true, arg2) {
        function parseFunctionArgs() {
            return typeof arg1 === 'string' ? [true, arg1] : [arg1, arg2];
        }
        const [enabled, message] = parseFunctionArgs();
        failMessage = message;
        showHelpOnFail = enabled;
        return self;
    };
    let failureOutput = false;
    self.fail = function fail(msg, err) {
        const logger = yargs._getLoggerInstance();
        if (fails.length) {
            for (let i = fails.length - 1; i >= 0; --i) {
                fails[i](msg, err, self);
            }
        }
        else {
            if (yargs.getExitProcess())
                setBlocking(true);
            if (!failureOutput) {
                failureOutput = true;
                if (showHelpOnFail) {
                    yargs.showHelp('error');
                    logger.error();
                }
                if (msg || err)
                    logger.error(msg || err);
                if (failMessage) {
                    if (msg || err)
                        logger.error('');
                    logger.error(failMessage);
                }
            }
            err = err || new YError(msg);
            if (yargs.getExitProcess()) {
                return yargs.exit(1);
            }
            else if (yargs._hasParseCallback()) {
                return yargs.exit(1, err);
            }
            else {
                throw err;
            }
        }
    };
    let usages = [];
    let usageDisabled = false;
    self.usage = (msg, description) => {
        if (msg === null) {
            usageDisabled = true;
            usages = [];
            return self;
        }
        usageDisabled = false;
        usages.push([msg, description || '']);
        return self;
    };
    self.getUsage = () => {
        return usages;
    };
    self.getUsageDisabled = () => {
        return usageDisabled;
    };
    self.getPositionalGroupName = () => {
        return __('Positionals:');
    };
    let examples = [];
    self.example = (cmd, description) => {
        examples.push([cmd, description || '']);
    };
    let commands = [];
    self.command = function command(cmd, description, isDefault, aliases, deprecated = false) {
        if (isDefault) {
            commands = commands.map(cmdArray => {
                cmdArray[2] = false;
                return cmdArray;
            });
        }
        commands.push([cmd, description || '', isDefault, aliases, deprecated]);
    };
    self.getCommands = () => commands;
    let descriptions = {};
    self.describe = function describe(keyOrKeys, desc) {
        if (Array.isArray(keyOrKeys)) {
            keyOrKeys.forEach(k => {
                self.describe(k, desc);
            });
        }
        else if (typeof keyOrKeys === 'object') {
            Object.keys(keyOrKeys).forEach(k => {
                self.describe(k, keyOrKeys[k]);
            });
        }
        else {
            descriptions[keyOrKeys] = desc;
        }
    };
    self.getDescriptions = () => descriptions;
    let epilogs = [];
    self.epilog = msg => {
        epilogs.push(msg);
    };
    let wrapSet = false;
    let wrap;
    self.wrap = cols => {
        wrapSet = true;
        wrap = cols;
    };
    function getWrap() {
        if (!wrapSet) {
            wrap = windowWidth();
            wrapSet = true;
        }
        return wrap;
    }
    const deferY18nLookupPrefix = '__yargsString__:';
    self.deferY18nLookup = str => deferY18nLookupPrefix + str;
    self.help = function help() {
        if (cachedHelpMessage)
            return cachedHelpMessage;
        normalizeAliases();
        const base$0 = yargs.customScriptName
            ? yargs.$0
            : shim.path.basename(yargs.$0);
        const demandedOptions = yargs.getDemandedOptions();
        const demandedCommands = yargs.getDemandedCommands();
        const deprecatedOptions = yargs.getDeprecatedOptions();
        const groups = yargs.getGroups();
        const options = yargs.getOptions();
        let keys = [];
        keys = keys.concat(Object.keys(descriptions));
        keys = keys.concat(Object.keys(demandedOptions));
        keys = keys.concat(Object.keys(demandedCommands));
        keys = keys.concat(Object.keys(options.default));
        keys = keys.filter(filterHiddenOptions);
        keys = Object.keys(keys.reduce((acc, key) => {
            if (key !== '_')
                acc[key] = true;
            return acc;
        }, {}));
        const theWrap = getWrap();
        const ui = shim.cliui({
            width: theWrap,
            wrap: !!theWrap,
        });
        if (!usageDisabled) {
            if (usages.length) {
                usages.forEach(usage => {
                    ui.div(`${usage[0].replace(/\$0/g, base$0)}`);
                    if (usage[1]) {
                        ui.div({ text: `${usage[1]}`, padding: [1, 0, 0, 0] });
                    }
                });
                ui.div();
            }
            else if (commands.length) {
                let u = null;
                if (demandedCommands._) {
                    u = `${base$0} <${__('command')}>\n`;
                }
                else {
                    u = `${base$0} [${__('command')}]\n`;
                }
                ui.div(`${u}`);
            }
        }
        if (commands.length) {
            ui.div(__('Commands:'));
            const context = yargs.getContext();
            const parentCommands = context.commands.length
                ? `${context.commands.join(' ')} `
                : '';
            if (yargs.getParserConfiguration()['sort-commands'] === true) {
                commands = commands.sort((a, b) => a[0].localeCompare(b[0]));
            }
            commands.forEach(command => {
                const commandString = `${base$0} ${parentCommands}${command[0].replace(/^\$0 ?/, '')}`;
                ui.span({
                    text: commandString,
                    padding: [0, 2, 0, 2],
                    width: maxWidth(commands, theWrap, `${base$0}${parentCommands}`) + 4,
                }, { text: command[1] });
                const hints = [];
                if (command[2])
                    hints.push(`[${__('default')}]`);
                if (command[3] && command[3].length) {
                    hints.push(`[${__('aliases:')} ${command[3].join(', ')}]`);
                }
                if (command[4]) {
                    if (typeof command[4] === 'string') {
                        hints.push(`[${__('deprecated: %s', command[4])}]`);
                    }
                    else {
                        hints.push(`[${__('deprecated')}]`);
                    }
                }
                if (hints.length) {
                    ui.div({
                        text: hints.join(' '),
                        padding: [0, 0, 0, 2],
                        align: 'right',
                    });
                }
                else {
                    ui.div();
                }
            });
            ui.div();
        }
        const aliasKeys = (Object.keys(options.alias) || []).concat(Object.keys(yargs.parsed.newAliases) || []);
        keys = keys.filter(key => !yargs.parsed.newAliases[key] &&
            aliasKeys.every(alias => (options.alias[alias] || []).indexOf(key) === -1));
        const defaultGroup = __('Options:');
        if (!groups[defaultGroup])
            groups[defaultGroup] = [];
        addUngroupedKeys(keys, options.alias, groups, defaultGroup);
        const isLongSwitch = (sw) => /^--/.test(getText(sw));
        const displayedGroups = Object.keys(groups)
            .filter(groupName => groups[groupName].length > 0)
            .map(groupName => {
            const normalizedKeys = groups[groupName]
                .filter(filterHiddenOptions)
                .map(key => {
                if (~aliasKeys.indexOf(key))
                    return key;
                for (let i = 0, aliasKey; (aliasKey = aliasKeys[i]) !== undefined; i++) {
                    if (~(options.alias[aliasKey] || []).indexOf(key))
                        return aliasKey;
                }
                return key;
            });
            return { groupName, normalizedKeys };
        })
            .filter(({ normalizedKeys }) => normalizedKeys.length > 0)
            .map(({ groupName, normalizedKeys }) => {
            const switches = normalizedKeys.reduce((acc, key) => {
                acc[key] = [key]
                    .concat(options.alias[key] || [])
                    .map(sw => {
                    if (groupName === self.getPositionalGroupName())
                        return sw;
                    else {
                        return ((/^[0-9]$/.test(sw)
                            ? ~options.boolean.indexOf(key)
                                ? '-'
                                : '--'
                            : sw.length > 1
                                ? '--'
                                : '-') + sw);
                    }
                })
                    .sort((sw1, sw2) => isLongSwitch(sw1) === isLongSwitch(sw2)
                    ? 0
                    : isLongSwitch(sw1)
                        ? 1
                        : -1)
                    .join(', ');
                return acc;
            }, {});
            return { groupName, normalizedKeys, switches };
        });
        const shortSwitchesUsed = displayedGroups
            .filter(({ groupName }) => groupName !== self.getPositionalGroupName())
            .some(({ normalizedKeys, switches }) => !normalizedKeys.every(key => isLongSwitch(switches[key])));
        if (shortSwitchesUsed) {
            displayedGroups
                .filter(({ groupName }) => groupName !== self.getPositionalGroupName())
                .forEach(({ normalizedKeys, switches }) => {
                normalizedKeys.forEach(key => {
                    if (isLongSwitch(switches[key])) {
                        switches[key] = addIndentation(switches[key], '-x, '.length);
                    }
                });
            });
        }
        displayedGroups.forEach(({ groupName, normalizedKeys, switches }) => {
            ui.div(groupName);
            normalizedKeys.forEach(key => {
                const kswitch = switches[key];
                let desc = descriptions[key] || '';
                let type = null;
                if (~desc.lastIndexOf(deferY18nLookupPrefix))
                    desc = __(desc.substring(deferY18nLookupPrefix.length));
                if (~options.boolean.indexOf(key))
                    type = `[${__('boolean')}]`;
                if (~options.count.indexOf(key))
                    type = `[${__('count')}]`;
                if (~options.string.indexOf(key))
                    type = `[${__('string')}]`;
                if (~options.normalize.indexOf(key))
                    type = `[${__('string')}]`;
                if (~options.array.indexOf(key))
                    type = `[${__('array')}]`;
                if (~options.number.indexOf(key))
                    type = `[${__('number')}]`;
                const deprecatedExtra = (deprecated) => typeof deprecated === 'string'
                    ? `[${__('deprecated: %s', deprecated)}]`
                    : `[${__('deprecated')}]`;
                const extra = [
                    key in deprecatedOptions
                        ? deprecatedExtra(deprecatedOptions[key])
                        : null,
                    type,
                    key in demandedOptions ? `[${__('required')}]` : null,
                    options.choices && options.choices[key]
                        ? `[${__('choices:')} ${self.stringifiedValues(options.choices[key])}]`
                        : null,
                    defaultString(options.default[key], options.defaultDescription[key]),
                ]
                    .filter(Boolean)
                    .join(' ');
                ui.span({
                    text: getText(kswitch),
                    padding: [0, 2, 0, 2 + getIndentation(kswitch)],
                    width: maxWidth(switches, theWrap) + 4,
                }, desc);
                if (extra)
                    ui.div({ text: extra, padding: [0, 0, 0, 2], align: 'right' });
                else
                    ui.div();
            });
            ui.div();
        });
        if (examples.length) {
            ui.div(__('Examples:'));
            examples.forEach(example => {
                example[0] = example[0].replace(/\$0/g, base$0);
            });
            examples.forEach(example => {
                if (example[1] === '') {
                    ui.div({
                        text: example[0],
                        padding: [0, 2, 0, 2],
                    });
                }
                else {
                    ui.div({
                        text: example[0],
                        padding: [0, 2, 0, 2],
                        width: maxWidth(examples, theWrap) + 4,
                    }, {
                        text: example[1],
                    });
                }
            });
            ui.div();
        }
        if (epilogs.length > 0) {
            const e = epilogs
                .map(epilog => epilog.replace(/\$0/g, base$0))
                .join('\n');
            ui.div(`${e}\n`);
        }
        return ui.toString().replace(/\s*$/, '');
    };
    function maxWidth(table, theWrap, modifier) {
        let width = 0;
        if (!Array.isArray(table)) {
            table = Object.values(table).map(v => [v]);
        }
        table.forEach(v => {
            width = Math.max(shim.stringWidth(modifier ? `${modifier} ${getText(v[0])}` : getText(v[0])) + getIndentation(v[0]), width);
        });
        if (theWrap)
            width = Math.min(width, parseInt((theWrap * 0.5).toString(), 10));
        return width;
    }
    function normalizeAliases() {
        const demandedOptions = yargs.getDemandedOptions();
        const options = yargs.getOptions();
        (Object.keys(options.alias) || []).forEach(key => {
            options.alias[key].forEach(alias => {
                if (descriptions[alias])
                    self.describe(key, descriptions[alias]);
                if (alias in demandedOptions)
                    yargs.demandOption(key, demandedOptions[alias]);
                if (~options.boolean.indexOf(alias))
                    yargs.boolean(key);
                if (~options.count.indexOf(alias))
                    yargs.count(key);
                if (~options.string.indexOf(alias))
                    yargs.string(key);
                if (~options.normalize.indexOf(alias))
                    yargs.normalize(key);
                if (~options.array.indexOf(alias))
                    yargs.array(key);
                if (~options.number.indexOf(alias))
                    yargs.number(key);
            });
        });
    }
    let cachedHelpMessage;
    self.cacheHelpMessage = function () {
        cachedHelpMessage = this.help();
    };
    self.clearCachedHelpMessage = function () {
        cachedHelpMessage = undefined;
    };
    function addUngroupedKeys(keys, aliases, groups, defaultGroup) {
        let groupedKeys = [];
        let toCheck = null;
        Object.keys(groups).forEach(group => {
            groupedKeys = groupedKeys.concat(groups[group]);
        });
        keys.forEach(key => {
            toCheck = [key].concat(aliases[key]);
            if (!toCheck.some(k => groupedKeys.indexOf(k) !== -1)) {
                groups[defaultGroup].push(key);
            }
        });
        return groupedKeys;
    }
    function filterHiddenOptions(key) {
        return (yargs.getOptions().hiddenOptions.indexOf(key) < 0 ||
            yargs.parsed.argv[yargs.getOptions().showHiddenOpt]);
    }
    self.showHelp = (level) => {
        const logger = yargs._getLoggerInstance();
        if (!level)
            level = 'error';
        const emit = typeof level === 'function' ? level : logger[level];
        emit(self.help());
    };
    self.functionDescription = fn => {
        const description = fn.name
            ? shim.Parser.decamelize(fn.name, '-')
            : __('generated-value');
        return ['(', description, ')'].join('');
    };
    self.stringifiedValues = function stringifiedValues(values, separator) {
        let string = '';
        const sep = separator || ', ';
        const array = [].concat(values);
        if (!values || !array.length)
            return string;
        array.forEach(value => {
            if (string.length)
                string += sep;
            string += JSON.stringify(value);
        });
        return string;
    };
    function defaultString(value, defaultDescription) {
        let string = `[${__('default:')} `;
        if (value === undefined && !defaultDescription)
            return null;
        if (defaultDescription) {
            string += defaultDescription;
        }
        else {
            switch (typeof value) {
                case 'string':
                    string += `"${value}"`;
                    break;
                case 'object':
                    string += JSON.stringify(value);
                    break;
                default:
                    string += value;
            }
        }
        return `${string}]`;
    }
    function windowWidth() {
        const maxWidth = 80;
        if (shim.process.stdColumns) {
            return Math.min(maxWidth, shim.process.stdColumns);
        }
        else {
            return maxWidth;
        }
    }
    let version = null;
    self.version = ver => {
        version = ver;
    };
    self.showVersion = () => {
        const logger = yargs._getLoggerInstance();
        logger.log(version);
    };
    self.reset = function reset(localLookup) {
        failMessage = null;
        failureOutput = false;
        usages = [];
        usageDisabled = false;
        epilogs = [];
        examples = [];
        commands = [];
        descriptions = objFilter(descriptions, k => !localLookup[k]);
        return self;
    };
    const frozens = [];
    self.freeze = function freeze() {
        frozens.push({
            failMessage,
            failureOutput,
            usages,
            usageDisabled,
            epilogs,
            examples,
            commands,
            descriptions,
        });
    };
    self.unfreeze = function unfreeze() {
        const frozen = frozens.pop();
        assertNotStrictEqual(frozen, undefined, shim);
        ({
            failMessage,
            failureOutput,
            usages,
            usageDisabled,
            epilogs,
            examples,
            commands,
            descriptions,
        } = frozen);
    };
    return self;
}
function isIndentedText(text) {
    return typeof text === 'object';
}
function addIndentation(text, indent) {
    return isIndentedText(text)
        ? { text: text.text, indentation: text.indentation + indent }
        : { text, indentation: indent };
}
function getIndentation(text) {
    return isIndentedText(text) ? text.indentation : 0;
}
function getText(text) {
    return isIndentedText(text) ? text.text : text;
}

const completionShTemplate = `###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.bashrc
#    or {{app_path}} {{completion_command}} >> ~/.bash_profile on OSX.
#
_yargs_completions()
{
    local cur_word args type_list

    cur_word="\${COMP_WORDS[COMP_CWORD]}"
    args=("\${COMP_WORDS[@]}")

    # ask yargs to generate completions.
    type_list=$({{app_path}} --get-yargs-completions "\${args[@]}")

    COMPREPLY=( $(compgen -W "\${type_list}" -- \${cur_word}) )

    # if no match was found, fall back to filename completion
    if [ \${#COMPREPLY[@]} -eq 0 ]; then
      COMPREPLY=()
    fi

    return 0
}
complete -o default -F _yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
`;
const completionZshTemplate = `###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.zshrc
#    or {{app_path}} {{completion_command}} >> ~/.zsh_profile on OSX.
#
_{{app_name}}_yargs_completions()
{
  local reply
  local si=$IFS
  IFS=$'\n' reply=($(COMP_CWORD="$((CURRENT-1))" COMP_LINE="$BUFFER" COMP_POINT="$CURSOR" {{app_path}} --get-yargs-completions "\${words[@]}"))
  IFS=$si
  _describe 'values' reply
}
compdef _{{app_name}}_yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
`;

function completion(yargs, usage, command, shim) {
    const self = {
        completionKey: 'get-yargs-completions',
    };
    let aliases;
    self.setParsed = function setParsed(parsed) {
        aliases = parsed.aliases;
    };
    const zshShell = (shim.getEnv('SHELL') && shim.getEnv('SHELL').indexOf('zsh') !== -1) ||
        (shim.getEnv('ZSH_NAME') && shim.getEnv('ZSH_NAME').indexOf('zsh') !== -1);
    self.getCompletion = function getCompletion(args, done) {
        const completions = [];
        const current = args.length ? args[args.length - 1] : '';
        const argv = yargs.parse(args, true);
        const parentCommands = yargs.getContext().commands;
        function runCompletionFunction(argv) {
            assertNotStrictEqual(completionFunction, null, shim);
            if (isSyncCompletionFunction(completionFunction)) {
                const result = completionFunction(current, argv);
                if (isPromise(result)) {
                    return result
                        .then(list => {
                        shim.process.nextTick(() => {
                            done(list);
                        });
                    })
                        .catch(err => {
                        shim.process.nextTick(() => {
                            throw err;
                        });
                    });
                }
                return done(result);
            }
            else {
                return completionFunction(current, argv, completions => {
                    done(completions);
                });
            }
        }
        if (completionFunction) {
            return isPromise(argv)
                ? argv.then(runCompletionFunction)
                : runCompletionFunction(argv);
        }
        const handlers = command.getCommandHandlers();
        for (let i = 0, ii = args.length; i < ii; ++i) {
            if (handlers[args[i]] && handlers[args[i]].builder) {
                const builder = handlers[args[i]].builder;
                if (isCommandBuilderCallback(builder)) {
                    const y = yargs.reset();
                    builder(y);
                    return y.argv;
                }
            }
        }
        if (!current.match(/^-/) &&
            parentCommands[parentCommands.length - 1] !== current) {
            usage.getCommands().forEach(usageCommand => {
                const commandName = parseCommand(usageCommand[0]).cmd;
                if (args.indexOf(commandName) === -1) {
                    if (!zshShell) {
                        completions.push(commandName);
                    }
                    else {
                        const desc = usageCommand[1] || '';
                        completions.push(commandName.replace(/:/g, '\\:') + ':' + desc);
                    }
                }
            });
        }
        if (current.match(/^-/) || (current === '' && completions.length === 0)) {
            const descs = usage.getDescriptions();
            const options = yargs.getOptions();
            Object.keys(options.key).forEach(key => {
                const negable = !!options.configuration['boolean-negation'] &&
                    options.boolean.includes(key);
                let keyAndAliases = [key].concat(aliases[key] || []);
                if (negable)
                    keyAndAliases = keyAndAliases.concat(keyAndAliases.map(key => `no-${key}`));
                function completeOptionKey(key) {
                    const notInArgs = keyAndAliases.every(val => args.indexOf(`--${val}`) === -1);
                    if (notInArgs) {
                        const startsByTwoDashes = (s) => /^--/.test(s);
                        const isShortOption = (s) => /^[^0-9]$/.test(s);
                        const dashes = !startsByTwoDashes(current) && isShortOption(key) ? '-' : '--';
                        if (!zshShell) {
                            completions.push(dashes + key);
                        }
                        else {
                            const desc = descs[key] || '';
                            completions.push(dashes +
                                `${key.replace(/:/g, '\\:')}:${desc.replace('__yargsString__:', '')}`);
                        }
                    }
                }
                completeOptionKey(key);
                if (negable && !!options.default[key])
                    completeOptionKey(`no-${key}`);
            });
        }
        done(completions);
    };
    self.generateCompletionScript = function generateCompletionScript($0, cmd) {
        let script = zshShell
            ? completionZshTemplate
            : completionShTemplate;
        const name = shim.path.basename($0);
        if ($0.match(/\.js$/))
            $0 = `./${$0}`;
        script = script.replace(/{{app_name}}/g, name);
        script = script.replace(/{{completion_command}}/g, cmd);
        return script.replace(/{{app_path}}/g, $0);
    };
    let completionFunction = null;
    self.registerFunction = fn => {
        completionFunction = fn;
    };
    return self;
}
function isSyncCompletionFunction(completionFunction) {
    return completionFunction.length < 3;
}

function levenshtein(a, b) {
    if (a.length === 0)
        return b.length;
    if (b.length === 0)
        return a.length;
    const matrix = [];
    let i;
    for (i = 0; i <= b.length; i++) {
        matrix[i] = [i];
    }
    let j;
    for (j = 0; j <= a.length; j++) {
        matrix[0][j] = j;
    }
    for (i = 1; i <= b.length; i++) {
        for (j = 1; j <= a.length; j++) {
            if (b.charAt(i - 1) === a.charAt(j - 1)) {
                matrix[i][j] = matrix[i - 1][j - 1];
            }
            else {
                matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, Math.min(matrix[i][j - 1] + 1, matrix[i - 1][j] + 1));
            }
        }
    }
    return matrix[b.length][a.length];
}

const specialKeys = ['$0', '--', '_'];
function validation(yargs, usage, y18n, shim) {
    const __ = y18n.__;
    const __n = y18n.__n;
    const self = {};
    self.nonOptionCount = function nonOptionCount(argv) {
        const demandedCommands = yargs.getDemandedCommands();
        const positionalCount = argv._.length + (argv['--'] ? argv['--'].length : 0);
        const _s = positionalCount - yargs.getContext().commands.length;
        if (demandedCommands._ &&
            (_s < demandedCommands._.min || _s > demandedCommands._.max)) {
            if (_s < demandedCommands._.min) {
                if (demandedCommands._.minMsg !== undefined) {
                    usage.fail(demandedCommands._.minMsg
                        ? demandedCommands._.minMsg
                            .replace(/\$0/g, _s.toString())
                            .replace(/\$1/, demandedCommands._.min.toString())
                        : null);
                }
                else {
                    usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', _s, _s.toString(), demandedCommands._.min.toString()));
                }
            }
            else if (_s > demandedCommands._.max) {
                if (demandedCommands._.maxMsg !== undefined) {
                    usage.fail(demandedCommands._.maxMsg
                        ? demandedCommands._.maxMsg
                            .replace(/\$0/g, _s.toString())
                            .replace(/\$1/, demandedCommands._.max.toString())
                        : null);
                }
                else {
                    usage.fail(__n('Too many non-option arguments: got %s, maximum of %s', 'Too many non-option arguments: got %s, maximum of %s', _s, _s.toString(), demandedCommands._.max.toString()));
                }
            }
        }
    };
    self.positionalCount = function positionalCount(required, observed) {
        if (observed < required) {
            usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', observed, observed + '', required + ''));
        }
    };
    self.requiredArguments = function requiredArguments(argv) {
        const demandedOptions = yargs.getDemandedOptions();
        let missing = null;
        for (const key of Object.keys(demandedOptions)) {
            if (!Object.prototype.hasOwnProperty.call(argv, key) ||
                typeof argv[key] === 'undefined') {
                missing = missing || {};
                missing[key] = demandedOptions[key];
            }
        }
        if (missing) {
            const customMsgs = [];
            for (const key of Object.keys(missing)) {
                const msg = missing[key];
                if (msg && customMsgs.indexOf(msg) < 0) {
                    customMsgs.push(msg);
                }
            }
            const customMsg = customMsgs.length ? `\n${customMsgs.join('\n')}` : '';
            usage.fail(__n('Missing required argument: %s', 'Missing required arguments: %s', Object.keys(missing).length, Object.keys(missing).join(', ') + customMsg));
        }
    };
    self.unknownArguments = function unknownArguments(argv, aliases, positionalMap, isDefaultCommand, checkPositionals = true) {
        const commandKeys = yargs.getCommandInstance().getCommands();
        const unknown = [];
        const currentContext = yargs.getContext();
        Object.keys(argv).forEach(key => {
            if (specialKeys.indexOf(key) === -1 &&
                !Object.prototype.hasOwnProperty.call(positionalMap, key) &&
                !Object.prototype.hasOwnProperty.call(yargs._getParseContext(), key) &&
                !self.isValidAndSomeAliasIsNotNew(key, aliases)) {
                unknown.push(key);
            }
        });
        if (checkPositionals &&
            (currentContext.commands.length > 0 ||
                commandKeys.length > 0 ||
                isDefaultCommand)) {
            argv._.slice(currentContext.commands.length).forEach(key => {
                if (commandKeys.indexOf('' + key) === -1) {
                    unknown.push('' + key);
                }
            });
        }
        if (unknown.length > 0) {
            usage.fail(__n('Unknown argument: %s', 'Unknown arguments: %s', unknown.length, unknown.join(', ')));
        }
    };
    self.unknownCommands = function unknownCommands(argv) {
        const commandKeys = yargs.getCommandInstance().getCommands();
        const unknown = [];
        const currentContext = yargs.getContext();
        if (currentContext.commands.length > 0 || commandKeys.length > 0) {
            argv._.slice(currentContext.commands.length).forEach(key => {
                if (commandKeys.indexOf('' + key) === -1) {
                    unknown.push('' + key);
                }
            });
        }
        if (unknown.length > 0) {
            usage.fail(__n('Unknown command: %s', 'Unknown commands: %s', unknown.length, unknown.join(', ')));
            return true;
        }
        else {
            return false;
        }
    };
    self.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew(key, aliases) {
        if (!Object.prototype.hasOwnProperty.call(aliases, key)) {
            return false;
        }
        const newAliases = yargs.parsed.newAliases;
        for (const a of [key, ...aliases[key]]) {
            if (!Object.prototype.hasOwnProperty.call(newAliases, a) ||
                !newAliases[key]) {
                return true;
            }
        }
        return false;
    };
    self.limitedChoices = function limitedChoices(argv) {
        const options = yargs.getOptions();
        const invalid = {};
        if (!Object.keys(options.choices).length)
            return;
        Object.keys(argv).forEach(key => {
            if (specialKeys.indexOf(key) === -1 &&
                Object.prototype.hasOwnProperty.call(options.choices, key)) {
                [].concat(argv[key]).forEach(value => {
                    if (options.choices[key].indexOf(value) === -1 &&
                        value !== undefined) {
                        invalid[key] = (invalid[key] || []).concat(value);
                    }
                });
            }
        });
        const invalidKeys = Object.keys(invalid);
        if (!invalidKeys.length)
            return;
        let msg = __('Invalid values:');
        invalidKeys.forEach(key => {
            msg += `\n  ${__('Argument: %s, Given: %s, Choices: %s', key, usage.stringifiedValues(invalid[key]), usage.stringifiedValues(options.choices[key]))}`;
        });
        usage.fail(msg);
    };
    let checks = [];
    self.check = function check(f, global) {
        checks.push({
            func: f,
            global,
        });
    };
    self.customChecks = function customChecks(argv, aliases) {
        for (let i = 0, f; (f = checks[i]) !== undefined; i++) {
            const func = f.func;
            let result = null;
            try {
                result = func(argv, aliases);
            }
            catch (err) {
                usage.fail(err.message ? err.message : err, err);
                continue;
            }
            if (!result) {
                usage.fail(__('Argument check failed: %s', func.toString()));
            }
            else if (typeof result === 'string' || result instanceof Error) {
                usage.fail(result.toString(), result);
            }
        }
    };
    let implied = {};
    self.implies = function implies(key, value) {
        argsert('<string|object> [array|number|string]', [key, value], arguments.length);
        if (typeof key === 'object') {
            Object.keys(key).forEach(k => {
                self.implies(k, key[k]);
            });
        }
        else {
            yargs.global(key);
            if (!implied[key]) {
                implied[key] = [];
            }
            if (Array.isArray(value)) {
                value.forEach(i => self.implies(key, i));
            }
            else {
                assertNotStrictEqual(value, undefined, shim);
                implied[key].push(value);
            }
        }
    };
    self.getImplied = function getImplied() {
        return implied;
    };
    function keyExists(argv, val) {
        const num = Number(val);
        val = isNaN(num) ? val : num;
        if (typeof val === 'number') {
            val = argv._.length >= val;
        }
        else if (val.match(/^--no-.+/)) {
            val = val.match(/^--no-(.+)/)[1];
            val = !argv[val];
        }
        else {
            val = argv[val];
        }
        return val;
    }
    self.implications = function implications(argv) {
        const implyFail = [];
        Object.keys(implied).forEach(key => {
            const origKey = key;
            (implied[key] || []).forEach(value => {
                let key = origKey;
                const origValue = value;
                key = keyExists(argv, key);
                value = keyExists(argv, value);
                if (key && !value) {
                    implyFail.push(` ${origKey} -> ${origValue}`);
                }
            });
        });
        if (implyFail.length) {
            let msg = `${__('Implications failed:')}\n`;
            implyFail.forEach(value => {
                msg += value;
            });
            usage.fail(msg);
        }
    };
    let conflicting = {};
    self.conflicts = function conflicts(key, value) {
        argsert('<string|object> [array|string]', [key, value], arguments.length);
        if (typeof key === 'object') {
            Object.keys(key).forEach(k => {
                self.conflicts(k, key[k]);
            });
        }
        else {
            yargs.global(key);
            if (!conflicting[key]) {
                conflicting[key] = [];
            }
            if (Array.isArray(value)) {
                value.forEach(i => self.conflicts(key, i));
            }
            else {
                conflicting[key].push(value);
            }
        }
    };
    self.getConflicting = () => conflicting;
    self.conflicting = function conflictingFn(argv) {
        Object.keys(argv).forEach(key => {
            if (conflicting[key]) {
                conflicting[key].forEach(value => {
                    if (value && argv[key] !== undefined && argv[value] !== undefined) {
                        usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));
                    }
                });
            }
        });
    };
    self.recommendCommands = function recommendCommands(cmd, potentialCommands) {
        const threshold = 3;
        potentialCommands = potentialCommands.sort((a, b) => b.length - a.length);
        let recommended = null;
        let bestDistance = Infinity;
        for (let i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++) {
            const d = levenshtein(cmd, candidate);
            if (d <= threshold && d < bestDistance) {
                bestDistance = d;
                recommended = candidate;
            }
        }
        if (recommended)
            usage.fail(__('Did you mean %s?', recommended));
    };
    self.reset = function reset(localLookup) {
        implied = objFilter(implied, k => !localLookup[k]);
        conflicting = objFilter(conflicting, k => !localLookup[k]);
        checks = checks.filter(c => c.global);
        return self;
    };
    const frozens = [];
    self.freeze = function freeze() {
        frozens.push({
            implied,
            checks,
            conflicting,
        });
    };
    self.unfreeze = function unfreeze() {
        const frozen = frozens.pop();
        assertNotStrictEqual(frozen, undefined, shim);
        ({ implied, checks, conflicting } = frozen);
    };
    return self;
}

let shim$1;
function YargsWithShim(_shim) {
    shim$1 = _shim;
    return Yargs;
}
function Yargs(processArgs = [], cwd = shim$1.process.cwd(), parentRequire) {
    const self = {};
    let command$1;
    let completion$1 = null;
    let groups = {};
    const globalMiddleware = [];
    let output = '';
    const preservedGroups = {};
    let usage$1;
    let validation$1;
    let handlerFinishCommand = null;
    const y18n = shim$1.y18n;
    self.middleware = globalMiddlewareFactory(globalMiddleware, self);
    self.scriptName = function (scriptName) {
        self.customScriptName = true;
        self.$0 = scriptName;
        return self;
    };
    let default$0;
    if (/\b(node|iojs|electron)(\.exe)?$/.test(shim$1.process.argv()[0])) {
        default$0 = shim$1.process.argv().slice(1, 2);
    }
    else {
        default$0 = shim$1.process.argv().slice(0, 1);
    }
    self.$0 = default$0
        .map(x => {
        const b = rebase(cwd, x);
        return x.match(/^(\/|([a-zA-Z]:)?\\)/) && b.length < x.length ? b : x;
    })
        .join(' ')
        .trim();
    if (shim$1.getEnv('_') && shim$1.getProcessArgvBin() === shim$1.getEnv('_')) {
        self.$0 = shim$1
            .getEnv('_')
            .replace(`${shim$1.path.dirname(shim$1.process.execPath())}/`, '');
    }
    const context = { resets: -1, commands: [], fullCommands: [], files: [] };
    self.getContext = () => context;
    let hasOutput = false;
    let exitError = null;
    self.exit = (code, err) => {
        hasOutput = true;
        exitError = err;
        if (exitProcess)
            shim$1.process.exit(code);
    };
    let completionCommand = null;
    self.completion = function (cmd, desc, fn) {
        argsert('[string] [string|boolean|function] [function]', [cmd, desc, fn], arguments.length);
        if (typeof desc === 'function') {
            fn = desc;
            desc = undefined;
        }
 HLEfA  H=H	 jZjAYCm H]UHI1H=H&	 jXjAYHm ]UHHHLEfA  H=H	 jZjAYl H]UHHHLEfA  H=TH-	 jZjAYl H]UHH HPDH HEHLEA @I@fA@@IpH=H:	 jAYH   Ol HPDH H;EuH ]l UHHHLEfA  H=H	 jZjAYl H]UHH fF FHVfF HNH=qHz	 jZjAYLIk ]UHH HPDH HEHLEA   I@fA@ IpH=Hu	 jXjAYHdk HPDH H;EuH ]7k UHAVSIHH:k    CH=H[	 jAYL   Ik [A^]UHH HkPDH HELEA @IxH=vHO	 jZjAYj H4PDH H;EuH ]j UHAVSH IHHPDH HEfj  LEA @IXfA@ A@H=Hz jAYL   Oj HPDH H;Eu	H [A^]j UHAVSH IHHPDH HEi  LEA @IXfA@ A@H=H=	 jAYL   i H=PDH H;Eu	H [A^]i UHH HPDH HELEA @IxfA@@IpH=H`	 jAYH   ei HPDH H;EuH ]2i UHAVSH IHHPDH HEi  LEA @IXfA@ A@H=H&	 jAYL   h HVPDH H;Eu	H [A^]h UHAVSH IHH'PDH HEh  LEA @IXfA@ A@H= H jAYL   nh HPDH H;Eu	H [A^]8h UHAWAVSH(IIHPDH HEh  LEA  AXfA@@Mx
fA@ A@H=
H	 jAYL   g HMPDH H;EuH([A^A_]g UHAWAVAUATSH  HPDH HEIIj-[jrA\DCjwA]AH@jxA_DD DDLHDD EDDH=p A9,DDDDDDHBH B(B$BHB HHB0HHB@HHB`HBt}f  L0A @HIHf fAHAXf fAPH IpfAH,ApfAH"Ap$fAH(Ap*fAH.Ap0fAH4Ap6fAH: Ap<fAH@EpBfAHFE`HfAHLEhNfAHRExTfAHX(ApZfAH^$Ap`fAHdApffAPjHIplfAPtHIpvfAP~HI   fA   HI   fA   A   fA   A   H=Hy	 H   A   (e HPDH H;EuH  [A\A]A^A_]d UHAWAVAUATSH  HXPDH HEIIj-[jrA\DCjwA]AH@jxA_DD DDHHDD EDDH A,DDDDDDHFH F(F$FHF HHF0HHF@HHF`HFtc  L0A @HIHf fAHAXf fAPH IpfAH,ApfAH"Ap$fAH(Ap*fAH.Ap0fAH4Ap6fAH: Ap<fAH@EpBfAHFE`HfAHLEhNfAHRExTfAHX(ApZfAH^$Ap`fAHdApffAPjHIplfAPtHIpvfAP~HI   fA   HI   fA   A   fA   A   H=H	 H   A   gb HPDH H;EuH  [A\A]A^A_](b UHH0HPDH HEHH{ H{ HDLEA  H I@fA@ IHfA@@IpH=|Hu j AYH   a H5PDH H;EuH0]a UHAWAVSH(IIHPDH HEca  LEA  AXfA@@Mx
fA@ A@H=H	 jAYL   Aa HPDH H;EuH([A^A_]	a UHAWAVSH(IIHwPDH HE`  LEA  AXfA@@Mx
fA@ A@H=eH~ jAYL   ` HPDH H;EuH([A^A_]{` UHAVSH IHPDH HEL`  LEA   AXfA@ A@
H=H	 jAYL   5` HPDH H;Eu	H [A^]_ UHAVSH IHtPDH HEH__  LEA   IXfA@ A@H=iH	 jAYL   _ H"PDH H;Eu	H [A^]_ UHHHLEfA  H=H	 jZjAYq_ H]UHH0HPDH HEHHx Hx HDLEA  Hb I@fA@ IHfA@@IpH=Hr j AYH   ^ HZPDH H;EuH0]^ UHAWAVATSH0IAIH'PDH HEH^  LEA @IXf fAHE`fA@@MxfAHA@H=H 	 j"AYL   U^ HPDH H;EuH0[A\A^A_]^ UHAWAVSH(IIHPDH HE]  LEA  AXfA@@Mx
fA@ A@H=w H jAYL   ] H0PDH H;EuH([A^A_]] UHH0HPDH HEHH%w Hw HDLEA  H I@fA@ IHfA@@IpH=Hp j AYH   /] HPDH H;EuH0]\ UHH0HwPDH HEHHv Hzv HDLEA  H I@fA@ IHfA@@IpH=PHYp j AYH   \ H	PDH H;EuH0]k\ UHAWAVSH(IAHPDH HEPDHn` H(\  LEA  ExfA@@IX
fA@ A@H=H jAYL   \ HPDHhPDH H;EuH([A^A_][ UHH0H@PDH HEHH]u HCu HDLEA  H I@fA@ IHfA@@IpH=H"o j AYH   g[ HPDH H;EuH0]4[ UHAWAVSH(IAHPDH HEHZ  LEA  ExfA@@IX
fA@ A@H=H jAYL   Z HHPDH H;EuH([A^A_]Z UHAWAVSH(IHPDH HEL>qZ  LEA  AXfA@@Mx
fA@ A@H=HZ	 jAYL   OZ HPDH H;EuH([A^A_]Z UHAWAVSH(IIHPDH HEY  LEA  AXfA@@Mx
fA@ A@H=sH	 jAYL   Y H,PDH H;EuH([A^A_]Y UHAWAVSH(IAHPDH HEUY  LEA   AXf fAHEx
fAHA@H=H	 jAYL   3Y HPDH H;EuH([A^A_]X UHAWAVAUATSH8MIHePDH HED&L*X  LEA  AXf@fAHMx
f fAPE`fAHMhfAP"A@$H=7HP	 j(AYL   X HPDH H;EuH8[A\A]A^A_]IX UHAVSH IHHPDH HEX  LEA   IXfA@ A@H=H	 jZjAYLW HoPDH H;Eu	H [A^]W UHH HIPDH HEHLEA   I@fA@ IpH=FH	 jXjAYHW HPDH H;EuH ]aW UHH0HPDH HEHHp Hp HDLEA  H I@fA@ IHfA@@IpH=Hj j AYH   W HnPDH H;EuH0]V UHH0HKPDH HEHHhp HNp HDLEA  HT I@fA@ IHfA@@IpH=$H-j j AYH   rV HPDH H;EuH0]?V UHH0HPDH HEHHo Ho HDLEA  H I@fA@ IHfA@@IpH=Hi j AYH   U HLPDH H;EuH0]U UHH0H)PDH HEHHFo H,o HDLEA  H2 I@fA@ IHfA@@IpH=H jXj AYHJU HPDH H;EuH0]U UHAWAVAUATSH8MAHPDH HEHL&Lj0T  LEA @IXf fAHExfA@@M`fA@ MhfAH&A@(H=WH`	 jZj,AYLT HPDH H;EuH8[A\A]A^A_]kT UHH0HPDH HEHH6HR0LEA @I@fA@@IpfA@ IPH=H:	 jZj AYHHT HPDH H;EuH0]S UHH0HfPDH HEHHm Him HDLEA  H I@fA@ IHfA@@IpH=?HHg j AYH   S HPDH H;EuH0]ZS UHH0HPDH HEHHl Hl HDLEA  H( I@fA@ IHfA@@IpH=Hf j AYH   R HgPDH H;EuH0]R UHH0HDPDH HEHHal HGl HDLEA  H I@fA@ IHfA@@IpH=H&f j AYH   kR HPDH H;EuH0]8R UHAWAVAUATSHXLMEAHPDH HEHL.Lr@Q  LEA @IXf fAHE`fA@@MhfAHExfA@" Mp$fAH,A@.H=eH	 jZj2AYHuQ HPDH H;EuHX[A\A]A^A_]xQ UHAWAVSH(IHPDH HEHL>Hz8H5{XDPDLEA @IXfA@@MxfA@ I@H=H	 jZj AYLQ HPDH H;EuH([A^A_]P UHSHHHXPDH HEP  LEA   A@H=\H	 jAYH   P HPDH H;EuH[]vP UHH HPDH HELEA @IxH=H5	 jAY   MP HPDH H;EuH ]P UHAWAVSH(IIHPDH HEH5&XDPDYHT HLEA @I@fA@@MxH=kH	 jAYL   O HRPDHPDH H;EuH([A^A_]xO UHH HPDH HELEA @IxH=H'	 jAY   OO HPDH H;EuH ]O UHAWAVSH(IIHPDH HEH5%XDPDXHS HLEA @I@fA@@MxH=mH	 jAYL   N HTPDHPDH H;EuH([A^A_]zN UHH HPDH HELEA @IxH= H	 jAY   QN HPDH H;EuH ]N UHHHLEfA  H=HN	 jZAN H]UHHHLEfA  H=H	 jZjAYM H]UHH H2PDH HELEA @IxfA@@IpH=2H[	 jXjAYHM HPDH H;EuH ]MM UHAWAVAUATSHIIHPDH HEH?L-PDAHEQ IH5"XDHAH-Q HQ HHLALEA  I@H=H	 jZjAYLL L5nPDHALAH+PDH H;EuH[A\A]A^A_]L UHAWAVATSH IIHPDH HEH?H	PDHP IH5!XDHHhP HLEA @I@fA@@MxH=H	 jAYL   L L5PDHALAHjPDH H;EuH [A\A^A_]K UHAWAVAUATSHIIH1PDH HEH?L-HPDAHO IH5!XDHAHO HO HHLALEA  I@H=H	 jZjAYLQK L5PDHALAHPDH H;EuH[A\A]A^A_]J UHAWAVATSH IIHjPDH HEH?HPDHN IH5M XDHHN HLEA @I@fA@@MxH=<Hu	 jAYL   J L5%PDHALAHPDH H;EuH [A\A^A_]=J UHH HPDH HELEA @IxH=Hl	 jAY   J HPDH H;EuH ]I UHSHHHXPDH HEI  LEA   A@H=\H	 jAYH   I HPDH H;EuH[]vI UHSH(HHPDH HEKI  LEA  H1 IHfA@ A@H=H	 jAYH   -I HPDH H;EuH([]H UHSH(HHpPDH HEH  LEA  H| IHfA@ A@H=bH	 jAYH   H HPDH H;EuH([]|H UHSH(HHPDH HEQH  LEA  H'| IHfA@ A@H=H	 jAYH   3H HPDH H;EuH([]G UHHHLEfA  H=H_	 jZAG H]UHSH(HHCPDH HEG  LEA  HV{ IHfA@ A@H=5H>	 jAYH   G HPDH H;EuH([]OG UHAWAVSH(IIHPDH HEH5YXDPDHKK HLEA @I@fA@@MxH=H@	 jZjAYLF HPDHYPDH H;EuH([A^A_]F UHSHHH-PDH HEF  LEA   A@H=1H	 jAYH   F HPDH H;EuH[]KF UHSHHHPDH HE F  LEA   A@H=H	 jAYH   F HPDH H;EuH[]E UHSHHHWPDH HEE  LEA   A@H=[Hd	 jAYH   E HPDH H;EuH[]uE UHHHLEfA  H=H	 jZjAYeE H]UHH0HPDH HEHH^ H^ HDLEA  Hl I@fA@ IHfA@@IpH=HX j AYH   D HNPDH H;EuH0]D UHAWAVSH(IIHPDH HE|D  LEA  AXfA@@Mx
fA@ A@H=H% jAYL   ZD HPDH H;EuH([A^A_]"D UHH HPDH HELEA  ApfA@@Ix
H=H	 jXjAYHC HVPDH H;EuH ]C UHAWAVAUATSH8MAIH!PDH HEL.zC  LEA  AXf@fAHMh
f fAPE`fAHMxfAP"A@$H=H	 jZj(AYL>C HPDH H;EuH8[A\A]A^A_]C UHH0MHPDH HEH6H	LEA  A@f@fA@Ip
fA@IPfA@IHH=dH	 jZj&AYLB HPDH H;EuH0]B UHAVSH IHHPDH HEQB  LEA @IXfA@ A@H=HU	 jAYL   :B HPDH H;Eu	H [A^]B UHH0HPDH HEHH[ H[ HDLEA  H I@fA@ IHfA@@IpH=XHaU j AYH   A HPDH H;EuH0]sA UHH0HPDH HEHH[ HZ HDLEA  H I@fA@ IHfA@@IpH=HT j AYH   A HPDH H;EuH0]@ UHH H]PDH HELEA @IxfA@@IpH=]H	 jXjAYH@ HPDH H;EuH ]x@ UHHHLEfA  H=H8	 jZjAYh@ H]UHAWAVAUATSH8MEIHPDH HED/H>HPDH7D HM$$?  LEA  Ehf@fAHIX
f fAPExfAHM`fAP"A@$H=gH	 jZj(AYL? HPPDHPDH H;EuH8[A\A]A^A_]r? UHH0HPDH HEHH
Y HX HDLEA  H7 I@fA@ IHfA@@IpH=Hm jXj AYH? HPDH H;EuH0]> UHH H\PDH HELEA @IxfA@@IpH=\H	 jXjAYH> HPDH H;EuH ]w> UHHHLEfA  H=H7	 jZjAYg> H]UHHHLEfA  H=Hs	 jZA(> H]UHHHLEfA  H=H	 jZA= H]UHHHLEfA  H=tH	 jZA= H]UHH H%PDH HE?H H HDLEA  IpfA@ IHH=H	 jXjAYHX= HPDH H;EuH ]+= UHAWAVATSH0IIIHPDH HE<  LEA   AXf fAHM`
fAHMxfA@ A@H=wHP	 jZj"AYL< H2PDH H;EuH0[A\A^A_]< UHAWAVATSH0IIIHPDH HET<  LEA   AXf fAHM`
fAHMxfA@ A@H=H	 jZj"AYL#< HPDH H;EuH0[A\A^A_]; UHAWAVATSH0IIIHXPDH HE;  LEA   AXf fAHM`
fAHMxfA@ A@H=;H	 j"AYL   ; HPDH H;EuH0[A\A^A_]O; UHH0HPDH HELEA   Axf fA@Ip
fA@IPH=H	 jZjAYHH; HwPDH H;EuH0]: UHH0MHQPDH HELEA   Ipf fApAPfApA@fA@ IHH=9H	 jZj"AYL: HPDH H;EuH0]V: UHAWAVAUATSH8MIIAHPDH HEH:  LEA   IXf fAHEhf fAPM`fAPMxfAH&A@(H=H	 jZj,AYL9 HLPDH H;EuH8[A\A]A^A_]9 UHHHLEfA  H=<Hu	 jZA9 H]UHAVSH IHHPDH HEB9  LEA @IXfA@ A@H=HV	 jAYL   +9 HPDH H;Eu	H [A^]8 UHAVSH IHjPDH HEH_08  LEA  IXfA@ A@H=_H	 jAYL   8 HPDH H;Eu	H [A^]w8 UHH HPDH HEHH@LEA   I@H=H	 jZjAYC8 HPDH H;EuH ]8 UHH HPDH HELEA   IxH=H	 jZjAY7 HZPDH H;EuH ]7 UHH H7PDH HELEA @IxH=BH	 jZjAY7 H PDH H;EuH ]b7 UHH HPDH HEHGLEA   I@H=H]	 jZjAY17 HPDH H;EuH ]7 UHH0HPDH HEHNLEA @IxfA@ A@fA@ IHH=nH	 jXjAYH6 H'PDH H;EuH0]6 UHAWAVAUATSH   HPDH HEDGLHAj-A[jrAYDAC0EjwYEDHA@jxA^EEDA EEDAAEDHADADAEDHU <AADAEDHHHwD_W8W4HW H(HW0H HW@HtL@A   A@f fAPIp
f fA@<ApfA@0ApfA@Eh fA@$EP&fA@*Ex,fA@0E`2fA@6AX8fA@<EH>fA@BAHDfA@HEpJfA@NEXPfA@T8AHVfA@Z4AH\fAP`H(IHbfAPjH IHlfAPtHIHvfAP~HI   fA   A   H=2H+	 jXHA   t4 HPDH H;EuH   [A\A]A^A_];4 UHH HPDH HEHG HO(H   HXDHLEA   IHfA@ I@H=H%	 jZjAY3 HZPDH H;EuH ]3 UHHHLEfA  H=SH	 jZA3 H]UHHHLEfA  H= H	 jZjAYy3 H]UHHHLEfA  H=H	 jZjAYE3 H]UHH HPDH HEHG(LEA  IpfA@@I@H=H	 jXjAYH2 HQPDH H;EuH ]2 UHH H.PDH HEHG(LEA  IpfA@@I@H=*H	 jXjAYHr2 HPDH H;EuH ]E2 UHH HPDH HEHG(LEA  IpfA@@I@H=H	 jXjAYH2 HuPDH H;EuH ]1 UHH HRPDH HEHG(LEA  IpfA@@I@H=NH	 jXjAYH1 HPDH H;EuH ]i1 UHHHLEfA  H= H	 jZjAYY1 H]UHH HPDH HELEA @IxH=H	 jZjAY1 HyPDH H;EuH ]0 UHAWAVATSIHI4 IAfC@CHCH=XH	 jZjAYLM0 L>PD[A\A^A_]UHAWAVATSIHI4 IAfC@CHCH=H	 jAYL   MC0 LPD[A\A^A_]UHAWAVATSIHI24 IAfC@CHCH=H	 jAYL   M/ LzPD[A\A^A_]UHAWAVATSIHI3 IAfC@CHCH=4Hm	 jAYL   M/ LPD[A\A^A_]UHHHLEfA  H=HU	 jZA:/ H]UHAWAVAUATSPMIHI53 IA$fC CL{fC@HCH=Hw	 jZjAYLM. LtPDH[A\A]A^A_]UHHHLEfA  H=BH[	 jZjAY. H]UHH HPDH HELEA @IxH=HF	 jZjAYJ. HPDH H;EuH ]. UHAWAVATSIHI62 IAfC@CHCH=H	 jZjAYLM- LPD[A\A^A_]UHAWAVATSMMHfA@AHyfA@HqHGPDIH=-H	 jAYL   Ix- HPDLL[A\A^A_]UHAWAVSPMHfA@AHyfA@HqHPDIH=H3	 jAYL   I- LPDH[A^A_]UHAWAVATSIHI0 IAfC@CHCH=VH	 jAYL   M, L:PD[A\A^A_]UHHHLEfA  H=H	 jZjAYg, H]UHHHLEfA  H=HC	 jZA(, H]UHHHLEfA  H=H	 jZA+ H]UHAWAVATSMHL}fA ALAf@fAHyfAHqH\PDIH=BH	 jZj AYLI+ H*PDLL[A\A^A_]UHAWAVSH(IIHPDH HEH0H5cWDPDHU/ HLEA @I@fA@@MxH=Hj	 jAYL   * HPDHaPDH H;EuH([A^A_]* UHHHLEfA  H=UH~	 jZA* H]UHSHHHPDH HEPDLEA   I@H=H`	 jZjAYHQ* HPDH H;EuH[]#* UHHHLEfA  H=H	 jZA* H]UHHHLEfA  H=H jZjAY) H]UHH0H7PDH HEHHTC H:C HDLEA  H I@fA@ IHfA@@IpH=H= j AYH   ^) HPDH H;EuH0]+) UHH HPDH HEHLEA @I@H=Hg	 jZjAY) HlPDH H;EuH ]( UHH HIPDH HELEA @IxfA@ IpH=IH2	 jXjAYH( HPDH H;EuH ]d( UHHHLEfA  H=H	 jZjAYT( H]UHH HPDH HEHLEA   I@H=H~	 jZjAY ( HqPDH H;EuH ]' UHH0HNPDH HEHHkA HQA HDLEA  H I@fA@ IHfA@@IpH='HU jXj AYHo' HPDH H;EuH0]B' UHH0HPDH HEHH@ H@ HDLEA  Hi I@fA@ IHfA@@IpH=H_U jXj AYH& HOPDH H;EuH0]& UHH0H,PDH HEHHI@ H/@ HDLEA  HU I@fA@ IHfA@@IpH=H: j AYH   S& HPDH H;EuH0] & UHH HPDH HEHLEA @I@H=HL~	 jZjAY% HaPDH H;EuH ]% UHH0H>PDH HEHH[? HA? HDLEA  Hg I@fA@ IHfA@@IpH=H 9 j AYH   e% HPDH H;EuH0]2% UHH HPDH HEHLEA @I@H=H}	 jZjAY% HsPDH H;EuH ]$ UHH0HPPDH HEHHm> HS> HDLEA  Hy I@fA@ IHfA@@IpH=)H28 j AYH   w$ HPDH H;EuH0]D$ UHH HPDH HEHLEA @I@H=H|	 jZjAY $ HPDH H;EuH ]# UHH0HbPDH HEHH= He= HDLEA  H I@fA@ IHfA@@IpH=;HD7 j AYH   # HPDH H;EuH0]V# UHH HPDH HEHLEA @I@H=HB|	 jZjAY2# HPDH H;EuH ]" UHH0HtPDH HEHH< Hw< HDLEA  H I@fA@ IHfA@@IpH=MHV6 j AYH   " HPDH H;EuH0]h" UHH HPDH HEHLEA @I@H=HTz	 jZjAYD" HPDH H;EuH ]" UHH0HPDH HEHH; H; HDLEA  H I@fA@ IHfA@@IpH=_Hh5 j AYH   ! HPDH H;EuH0]z! UHH HPDH HEHLEA @I@H=H&y	 jZjAYV! HPDH H;EuH ]! UHHHLEfA  H=H}z	 jZjAY! H]UHH0HdPDH HEHH: Hg: HDLEA  H I@fA@ IHfA@@IpH==HF4 j AYH     HPDH H;EuH0]X  UHH HPDH HEHLEA @I@H=Hy	 jZjAY4  HPDH H;EuH ] UHH0HvPDH HEHH9 Hy9 HDLEA  H I@fA@ IHfA@@IpH=OHX3 j AYH    HPDH H;EuH0]j UHAWAVSH(IIHPDH HEH>H51WDH1PDH`# HLEA @MxfA@@I@H=Hy	 jZjAYL HPDHnPDH H;EuH([A^A_] UHH0HFPDH HEHHc8 HI8 HDLEA  H7 I@fA@ IHfA@@IpH=H(2 j AYH   m HPDH H;EuH0]: UHSPLH fA@AHyfA QH=Hy	 jAYL   I HPDH[]UHHHLEfA  H=wHy	 jAY    H]UHHHLEfA  H=AHx	 jZjAY H]UHHHLEfA  H=Hw	 jZjAYf H]UHHHLEfA  H=Hw	 jZjAY2 H]UHH0HPDH HEHHvLEA  I@fA@ IpfA@@IPH=wHv	 jZj AYHH H/PDH H;EuH0] UHAVSH IHPDH HEH?H5]WDPDH  HLEA @I@H=Hw	 jAYL   D HPDHPDH H;Eu	H [A^] UHAVSH IHzPDH HEH?H5WDPDH  HLEA @I@H=jHw	 jAYL    HQPDHPDH H;Eu	H [A^]y UHH HPDH HELEA @IxH=HXw	 jAY   P HPDH H;EuH ] UHAVSH IHHPDH HE LEA  IXfA@ I@H=H3> jZjAYL HEPDH H;Eu	H [A^] UHH HPDH HEHG HO(LEA @I@fA@@IHH=Hv	 jZjAYd HPDH H;EuH ]7 UHAVSH IHPDH HEHH~  LEA  IXfA@ I@H=Hy= jZjAYL H[PDH H;Eu	H [A^] UHHHLEfA  H=QH jZjAY H]UHH HPDH HELEA @IxH=Hv	 jZjAYe HPDH H;EuH ], UHHHLEfA  H=Hu	 jZjAY H]UHHHLEfA  H=Hu	 jZjAY H]UHHHLEfA  H=[Hu	 jZjAY H]UHHHLEfA  H='Hu	 jZjAY H]UHHHLEfA  H=Hu	 jZjAYL H]UHHHLEfA  H=Hv	 jZjAY H]UHSHHHkPDH HE LEA   A@H=oHv	 jZjAYH H*PDH H;EuH[] UHAWAVSH(IIHPDH HEH>H5WDPDH HLEA @MxfA@@I@H=Hu	 jAYL   . HPDHPDH H;EuH([A^A_] UHI1H=Hu	 jXjAYH ]UHAWAVATSMHL}fA ALAf@fAHyfAHqH>PDIH=$H-v	 jZj AYLIk HPDLL[A\A^A_]UHHHLEfA  H=HO jZjAY/ H]UHHHLEfA  H=Hku	 jZjAY H]UHH HRPDH HELEA @IxH=]Hu	 jZjAY HPDH H;EuH ]} UHH HPDH HEHLEA   I@H= Hiu	 jZjAYM HPDH H;EuH ]  UHH HPDH HELEA @IxfA@@IpH=H4u	 jXjAYH HTPDH H;EuH ] UHAWAVAUATSPMIHI IA$fC CL{fC@HCH="Hu	 jZjAYLMi LPDH[A\A]A^A_]UHH HPDH HELEA @IxfA@@IpH=H jXjAYH HsPDH H;EuH ] UHHHLEfA  H=lHeu	 jZjAY H]UHMHfA ALAfA@HyfA HqH=HVu	 jZj AYLId ]UHAWAVAUATSPMIHIc IA$fC CL{fC@HCH=H5u	 jZjAYLM LPDH[A\A]A^A_]UHH HTPDH HELEA   IxH=_Hu	 jZjAY HPDH H;EuH ] UHHHLEfA  H=Hou	 jZAd H]UHI fF FFH=Hu	 jXjAYH& ]UHH HPDH HEHLEA   I@H=Hq	 jZjAY HSPDH H;EuH ] UHAVSH IHH'PDH HEH? LEA  I@fA@@IXH=Ht	 jZjAYLi HPDH H;Eu	H [A^]9 UHAWAVAUATSPMMIHjXHHPDH8 IA$A@AHEL(H=H t	 jAYHujZI L|PDH[A\A]A^A_]UHSHHH*PDH HEEPDLEA   I@H=/H jZjAYHy HPDH H;EuH[]K UHHHLEfA  H=Hs	 jZjAY; H]UHH HPDH HELEA @IxH=HFs	 jZjAY H[PDH H;EuH ] UHSHHH4PDH HEH?LPDLEA   I@H=6Hos	 jZjAYH HPDH H;EuH[]R UHSHHHPDH HEH?PDLEA   I@H=HTs	 jZjAYH HPDH H;EuH[] UHH HbPDH HELEA @IxH=mH jAY    H)PDH H;EuH ] UHAWAVAUATSH(IIIHPDH HEH5WDHPDH} ILLHj HLEA @MhfA@@I@H=Hs	 jAYL    L5PDHALAHlPDH H;EuH([A\A]A^A_] UHAWAVAUATSH(IIIH.PDH HEH5WDHAPDH ILLH HLEA @MhfA@@I@H= H)s	 jAYL   N L5PDHALAHPDH H;EuH([A\A]A^A_] UHAWAVAUATSH(IIIHhPDH HEH5WDH{PDH ILLH HLEA @MhfA@@I@H=:Hcr	 jAYL    L5#PDHALAHPDH H;EuH([A\A]A^A_]9 UHAWAVATSH IHHPDH HEH5WDL%PDAIH5=WDHAH HLEA  MxfA@@I@H={HTp	 jZjAYL HdPDH-PDH H;EuH [A\A^A_] UHHHLEfA  H=Hxq	 jZjAYx H]UHAWAVSH(IIHPDH HEH5nWDPDHP HILEA @IXfA@@I@H=Hr	 jZjAYL
 HPDH[PDH H;EuH([A^A_]
 UHAVSH IHH*PDH HEH54WDH1;PDLEA  I@fA@@IXH=HSr	 jZjAYLd
 HPDH H;Eu	H [A^]4
 UHAWAVSH(IHIHPDH HEH5WDPDHLEA  I@f@fA@MxfA@IHH=HOq	 j AYL   	 H?PDH H;EuH([A^A_]	 UHAWAVSH(IIHPDH HEH5WD PDH HILEA @IXfA@@I@H=H
p	 jAYL   ?	 HPDHPDH H;EuH([A^A_] UHAWAVSH(IIHnPDH HEH5WDPDH HILEA @IXfA@@I@H=SHo	 jAYL    H:PDHPDH H;EuH([A^A_]` UHH HPDH HELEA @IxH=Ho	 jZjAY3 HPDH H;EuH ] UHAWAVAUATSHHLEIHILeHgPDH HEH?H5WDI1L=tPDAH HEH5.WDI4$HAHHELHAH IHLAH IH5WDLAH ILEA  HEI@f@fA@MhfA@MpH=Hm	 jZj AYHu' HPDLLLH}H|PDH H;EuHH[A\A]A^A_] UHHHLEfA  H=lH5`	 jZjAY H]UHHHLEfA  H=8Hl	 jZjAY H]UHAWAVSPMHfA ALAf@fAHyfAHqHPDIH=HPn	 jZj AYLI LPDH[A^A_]UHMH@L*P H=P HID@ID fA@ALAf fqHQfqHyH=UHn	 jZj AYLI ]UHH HPDH HELEA @IxfA@@IpH=Hn	 jXjAYHK HPDH H;EuH ] UHAWAVSPMHfA ALAf@fAHyfAHqHPDIH=HQm	 jZj AYLI LnPDH[A^A_]UHAVSH IHHPDH HE_ LEA  IXfA@ I@H=H' jZjAYL` HPDH H;Eu	H [A^]0 UHH0HPDH HEHH H HDLEA  Hk I@fA@ IHfA@@IpH=H j AYH    H=PDH H;EuH0] UHI1H==Hfm	 jXjAYH ]UHH HPDH HELEA @IxH=Hm	 jZjAYD HPDH H;EuH ] UHHHLEfA  H=HWn	 jZjAY H]UHH H^PDH HELEA @IxH=iHm	 jZjAY H'PDH H;EuH ] UHAWAVAUATSPLMMHII IA$fC@CHCfC@LkH=Hm	 jAYL   M< HPDLH}H[A\A]A^A_]UHHHLEfA  H=Hl	 jZA H]UHHHLEfA  H=gH jZA H]UHHHLEfA  H=4H} jZjAY H]UHAWAVSPHHH,4QDHELufA@ A@MHf@fAHIxfAHIpfAH I@"HPDIH=Hpk	 jZj*AYLI  LPDH[A^A_]UHAWAVSH(IIHHPDH HEH>H5wWDYPDH HLEA @MxfA@@I@H=-Hvl	 jZjAYLw  HPDHPDH H;EuH([A^A_]<  UHHHLEfA  H=Hl	 jZjAY,  H]UHAWAVAUATSPMMHIHu IA$fC CL{fC Lsf@fCLkfC HEHC"H=XHl	 jZj*AYHuM L=PDH[A\A]A^A_]UHAWAVAUATSPMIHI IA$fC CL{fC@HCH=H9l	 jZjAYLM' LPDH[A\A]A^A_]UHAWAVATSMHL}fA ALAf@fAHyfAHqH|PDIH=bHl	 jZj AYLI HJPDLL[A\A^A_]UHH HPDH HEHB|PDH LEA @I@fA@ IxH=Hk	 jZjAY; HPDH H;EuH ] UHAVSH IHPDH HEHH~  LEA  IXfA@ I@H=wHP! jZjAYL H2PDH H;Eu	H [A^] UHH@MH	PDH HELEA @Ixf@fA@IpfA@IPfA@ IH"H=Hnk	 jZj*AYL? HPDH H;EuH@] UHH HPDH HELEA @IxH=Hj	 jZjAY HVPDH H;EuH ] UHHHLEfA  H=OH8k	 jZjAY H]UHHHLEfA  H=Hk	 jZjAYt H]UHHHLEfA  H=Hk	 jZjAY@ H]UHHHLEfA  H=Hk	 jZjAY H]UHAWAVAUATSH   H`HhIHF~PDH HEH5WDH1L=VPDAH HXH5WDHAH HxH5XDLAH HpL5WDHLAHt HHEH5~XDLAHX HEHLAHC IH5WDLAH+ IHH56WDAH ILEA @LxMpf@fA@IXfA@MhfA@ Mx"fA@*HhI@,H=DH]i	 jZj4AYH` H+PDLLLH}H}HpLHXH|PDH H;EuH   [A\A]A^A_] UHHHLEfA  H=Hi	 jZjAY H]UHHHLEfA  H={Hi	 jZjAY H]UHI1H=NHj	 jXjAYH ]UHHHLEfA  H=Hj	 jZjAYr H]UHI1H=Hi	 jXjAYH@ ]UHH H{PDH HELEA @IxH=Hi	 jZjAY Hd{PDH H;EuH ] UHHHLEfA  H=]Hi	 jZjAY H]UHAWAVATSH IIH {PDH HEH5
XDH1H}PDH IHLHs HLEA @I@H=Hi	 jZjAYL$ L5|PDHALAHzPDH H;EuH [A\A^A_] UHHHLEfA  H=tHh	 jZjAY H]UHHHLEfA  H=@Hii	 jZjAY H]UHHHLEfA  H=Hui	 jZjAYe H]UHH HyPDH HELEA @IxH=Hi	 jZjAY HyPDH H;EuH ] UHHHLEfA  H=~H7i	 jZjAY H]UHH H.yPDH HEHF0LEA @IxfA@@I@H=*Hci	 jAYH   x HxPDH H;EuH ]E UHH HxPDH HELEA @IxH=Hi	 jAY    HxPDH H;EuH ] UHH HdxPDH HELEA @IxH=oHi	 jAY    H+xPDH H;EuH ] UHH HxPDH HELEA @IxH=Hi	 jAY   d HwPDH H;EuH ]1 UHI1H=HHj	 jXjAYH# ]UHI1H=HJj	 jXjAYH ]UHH=~ H5 H     UHHHLEfA  H=HHj	 jZA H]UHH HvPDH HELEA @IxfA@@IpH=Hj	 jXjAYHA HvPDH H;EuH ] UHH HvPDH HEHG LEA @I@fA@@IpH=Hi	 jAYH    HDvPDH H;EuH ] UHH H!vPDH HEHG LEA @I@fA@@IpH=Hi	 jAYH   k HuPDH H;EuH ]8 UHH HuPDH HEH RDHnQD@HEHF LEA @IHfA@@I@H=HRi	 jXjAYH HRuPDH H;EuH ] UHHHLEfA  H=KHTi	 jZjAY H]UHHHLEfA  H=Hi	 jZjAYp H]UHHHLEfA  H=H,i	 jZjAY< H]UHHHLEfA  H=Hi	 jZjAY H]UHHHLEfA  H={Hi	 jZjAY H]UHH H+tPDH HELEA @IxH=6Hi	 jZjAY HsPDH H;EuH ]V UHH HsPDH HELEA @IxH=Hei	 jZjAY) HsPDH H;EuH ] UHH HwsPDH HEHLEA   I@H=Hh	 jZjAY H=sPDH H;EuH ] UHH HsPDH HELEA @IxfA@@IpH=H3i	 jXjAYHn HrPDH H;EuH ]5 UHHHLEfA  H=Hj	 jZA H]UHAWAVATSMMHfA@AHyfA@HqHtPDIH=rHh	 jZjAYLI HZtPDLL[A\A^A_]UHHfA AHyfA@HqH=H_h	 jZjAYLIi ]UHH HqPDH HEHLEA  I@fA@@IpH=Hg	 jXjAYH	 HzqPDH H;EuH ] UHAVSH IHQqPDH HE H HLEA @I@H=LHu jZjAYL H5sPDHpPDH H;Eu	H [A^]] UHAVSH IHpPDH HE Hf HLEA @I@H=H jZjAYL# HrPDHpPDH H;Eu	H [A^] UHHHLEfA  H=uHh	 jZjAY H]UHH H%pPDH HEHLEA @I@H=-Hvh	 jAY   ~ HoPDH H;EuH ]K UHHHLEfA  H=Hg	 jZA0 H]UHH HoPDH HEHLEA @I@H=Hg	 jAY    HWoPDH H;EuH ] UHHHLEfA  H=PH	g	 jZA H]UHH HoPDH HELEA @IxH=Huf	 jZjAYY HnPDH H;EuH ], UHAWAVAUATSPMHII? IAfC@CHCfC@LcH=H&	 jAYL   M L}pPDH[A\A]A^A_]UHH H/nPDH HEHHN LEA  I@fA@@IHH=(He	 jXjAYHp HmPDH H;EuH ]C UHH HmPDH HEHLEA   I@H=Hof	 jZjAY HmPDH H;EuH ] UHH HamPDH HEHLEA   I@H=iHRf	 jZjAY H'mPDH H;EuH ] UHHHLEfA  H= H9f	 jZjAYy H]UHH HlPDH HELEA @IxfA@@IpH=H)f	 jAYH    HlPDH H;EuH ] UHHHLEfA  H=Hf	 jAY    H]UHHHLEfA  H=LHe	 jZA H]UHHHLEfA  H=He	 jZAg H]UHHHLEfA  H=He	 jAY   7 H]UHHHLEfA  H=He	 jAY    H]UHHHLEfA  H=zHf	 jZA H]UHHHLEfA  H=GH`f	 jAY    H]UHHHLEfA  H=Hf	 jZjAYj H]UHH HjPDH HEHLEA   I@H=HRf	 jZjAY HjPDH H;EuH ] UHHHLEfA  H=He	 jZjAY H]UHHHLEfA  H=LH5f	 jZjAY H]UHH HiPDH HEHLEA   I@H=Hl	 jZjAYQ HiPDH H;EuH ]$ UHH HiPDH HEHLEA   I@H=H@l	 jZjAY HeiPDH H;EuH ] UHH HBiPDH HEHLEA   I@H=JHk	 jZjAY HiPDH H;EuH ]j UHH HhPDH HEHLEA   I@H=H&k	 jZjAY: HhPDH H;EuH ] UHI1H=Hdj	 jXjAYH ]UHHHLEfA  H=vHi	 jZA H]UHH H'hPDH HEHLEA   I@H=/Hi	 jZjAY| HgPDH H;EuH ]O UHH HgPDH HEHLEA   I@H=Hkh	 jZjAY HgPDH H;EuH ] UHH HmgPDH HEHLEA   I@H=uHg	 jZjAY H3gPDH H;EuH ] UHH HgPDH HEHLEA   I@H=HAg	 jZjAYe HfPDH H;EuH ]8 UHH HfPDH HEHLEA   I@H=Hf	 jZjAY HyfPDH H;EuH ] UHH HVfPDH HEHLEA   I@H=^H'f	 jZjAY HfPDH H;EuH ]~ UHH HePDH HEHLEA   I@H=He	 jZjAYN HePDH H;EuH ]! UHH HePDH HEHLEA   I@H=He	 jZjAY HbePDH H;EuH ] UHH H?ePDH HEHLEA   I@H=GHd	 jZjAY HePDH H;EuH ]g UHH HdPDH HEHLEA   I@H=Hc	 jZjAY7 HdPDH H;EuH ]
 UHH HdPDH HEHLEA   I@H=Hfc	 jZjAY HKdPDH H;EuH ] UHH H(dPDH HEHLEA   I@H=0Hb	 jZjAY} HcPDH H;EuH ]P UHH HcPDH HEHLEA   I@H=Ha	 jZjAY  HcPDH H;EuH ] UHH HncPDH HEHLEA   I@H=vHoa	 jZjAY H4cPDH H;EuH ] UHH HcPDH HEHLEA   I@H=H`	 jZjAYf HbPDH H;EuH ]9 UHH HbPDH HEHLEA   I@H=HU`	 jZjAY	 HzbPDH H;EuH ] UHH HWbPDH HEHLEA   I@H=_H_	 jZjAY HbPDH H;EuH ] UHH HaPDH HEHLEA   I@H=H;_	 jZjAYO HaPDH H;EuH ]" UHH HaPDH HEHLEA   I@H=H^	 jZjAY HcaPDH H;EuH ] UHH H@aPDH HEHLEA   I@H=HH!^	 jZjAY HaPDH H;EuH ]h UHH H`PDH HEHLEA   I@H=H$]	 jZjAY8 H`PDH H;EuH ] UHH H`PDH HEHLEA   I@fA@ IpH=H\	 jXjAYH H<`PDH H;EuH ] UHHHLEfA  H=5Hb	 jZjAY H]UHHHLEfA  H=H*c	 jZjAYZ H]UHH H_PDH HEHLEA  I@fA@@IpH=Hb	 jXjAYH Hg_PDH H;EuH ] UHH HD_PDH HEHLEA @I@H=LHe	 jAY    H_PDH H;EuH ]j UHH H^PDH HEHLEA  I@fA@@IpH=~H;e	 jXjAYH* H^PDH H;EuH ] UHH Hx^PDH HELEA @IxH=~HLd	 jZjAY HA^PDH H;EuH ] UHI1H=A~Hc	 jXjAYH ]UHI1H=~Hb	 jXjAYHg ]UHH H]PDH HELEA @IxH=}Hb	 jAY    H]PDH H;EuH ] UHH Hf]PDH HEHLEA  I@fA@@IpH=c}Ha	 jXjAYH H]PDH H;EuH ]~ UHHHLEfA  H=}Hc	 jZAc H]UHHHLEfA  H=|Hc	 jZA0 H]UHHHLEfA  H=|Hc	 jZA H]UHH H`\PDH HEHLEA   I@H=h|Hc	 jZjAY H&\PDH H;EuH ] UHH H\PDH HEHLEA   I@H=|Hc	 jZjAYX H[PDH H;EuH ]+ UHH H[PDH HEHLEA   I@H={Hc	 jZjAY Hl[PDH H;EuH ] UHH HI[PDH HEHLEA   I@H=Q{Hf	 jZjAY H[PDH H;EuH ]q UHI1H={He	 jAYHDY ]UHI1H=zHe	 jXjAYH7 ]UHI1H=zHd	 jXjAYH	 ]UHH HdZPDH HEHLEA   I@H=lzHa	 jZjAY H*ZPDH H;EuH ] UHH HZPDH HEHLEA   I@H=zHb	 jZjAY\ HYPDH H;EuH ]/ UHH HYPDH HEHLEA   I@H=yHa	 jZjAY HpYPDH H;EuH ] UHH HMYPDH HELEA @IxH=XyH!e	 jZjAY HYPDH H;EuH ]x UHHHLEfA  H=yH(e	 jZjAYh H]UHHHLEfA  H=xHd	 jZjAY4 H]UHHHLEfA  H=xHp jZjAY  H]UHHHLEfA  H=sxH< jZjAY H]UHHHLEfA  H=?xH jZjAY H]UHHHLEfA  H=xH jZjAYd H]UHAVSH IHWPDH HEH5WDYPDHA HLEA @I@H=wH!d	 jZjAYL HYPDHZWPDH H;Eu	H [A^] UHH H4WPDH HELEA @IxH=?wHd	 jZjAY HVPDH H;EuH ]_ UHHHLEfA  H=vHc	 jZjAYO H]UHHHLEfA  H=vHkc	 jZjAY H]UHH HrVPDH HEHG LEA @I@H=yvHd	 jZjAY H7VPDH H;EuH ] UHH HVPDH HEHG LEA @I@H=vHc	 jZjAYh HUPDH H;EuH ]; UHSHHHUPDH HEH5TWDWPDLEA   I@H=uHc	 jZjAYH HkUPDH H;EuH[] UHHHLEfA  H=cuHl jZjAY H]UHHHLEfA  H=/uHd	 jZjAY H]UHH HTPDH HELEA @IxH=tHc	 jZjAY7 HTPDH H;EuH ]
 UHHHLEfA  H=tH*c	 jZA H]UHHHLEfA  H=ntHb	 jZjAY H]UHHHLEfA  H=:tHc	 jZjAY H]UHH HSPDH HELEA @IxH=sH.c	 jZjAYB HSPDH H;EuH ] UHHHLEfA  H=sHb	 jZA H]UHHHLEfA  H=ysHa	 jZjAY H]UHHHLEfA  H=EsH>c	 jZA H]UHH HRPDH HELEA @IxH=sHb	 jZjAYZ HRPDH H;EuH ]! UHHHLEfA  H=rH jZjAY H]UHHHLEfA  H=rHb	 jZjAY H]UHHHLEfA  H=PrHIc	 jZjAY H]UHHHLEfA  H=rHb	 jZjAYu H]UHHHLEfA  H=qHb	 jZjAYA H]UHH HQPDH HELEA @IxH=qHc	 jZjAY HaQPDH H;EuH ] UHH0H>QPDH HEHH@(HHR(LEA @Ixf@fApI@fApIPH=%qH^c	 j AYH   Hp HPPDH H;EuH0]= UHH0HPPDH HEHH@(H6Hv(HHR(LEA @I@f@fA@IpfA@IPH=pH!c	 jZj AYHH HPPPDH H;EuH0] UHH0H-PPDH HEHH@(H6Hv(HHR(LEA @I@f@fA@IpfA@IPH=pHa	 jZj AYHHT HOPDH H;EuH0]' UHH HOPDH HEHLEA  I@fA@@IpH=oH`	 jXjAYH HXOPDH H;EuH ] UHHHLEfA  H=QoH:[	 jZjAY H]UHHHLEfA  H=oHa	 jZjAYv H]UHH HNPDH HELEA @IxH=nHb	 jZjAY% HNPDH H;EuH ] UHH HsNPDH HELEA @IxH=~nHa	 jAY    H:NPDH H;EuH ] UHH HNPDH HEHLEA  I@fA@@IpH=nH`	 jXjAYH\ HMPDH H;EuH ]/ UHHHLEfA  H=mHa	 jZjAY H]UHAWAVAUATSH(IIHHdMPDH HEH5>WDL-wOPDAH IH5RWDI7HAH HLEA @M`fA@@I@H=-mH`	 jZjAYLw L5OPDHALAHLPDH H;EuH([A\A]A^A_]. UHHHLEfA  H=lH>E	 jZjAY H]UHHHLEfA  H=lH`	 jZjAY H]UHHHLEfA  H=]lHO jZjAY H]UHH HLPDH HELEA @IxfA@@IpH=lHV`	 jXjAYHU HKPDH H;EuH ]( UHHHLEfA  H=kH_	 jZj